{\rtf1\ansi\ansicpg1252\cocoartf1561
{\fonttbl\f0\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;\red14\green14\blue14;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c6667\c6667\c6667;\cssrgb\c100000\c100000\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl320\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Encapsulation is most commonly associated with object-oriented programming (OOP) but the concept itself is in fact separate from it and can be implemented in the absence of any OOP pattern, including prototypal, as is the case in JavaScript. The two notions that define this concept are:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 bundling the data\'a0
\b with
\b0 \'a0the methods of a module and\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 restricting direct access to a module's components\cb1 \
\pard\pardeftab720\sl320\sa280\partightenfactor0
\cf2 \cb3 The intent of the first notion is to prevent the user of the module from setting the module into an invalid or inconsistent state that was not intended by the module's creator. Both notions make code more understandable and maintainable which can be considered the most important concept of all, particularly from a developer's point of view.\
Modularization provides another way to develop code that is more understandable and maintainable. In addition, it prevents real-time issues that can occur with namespaces by keeping components (and associated code) out of the global namespace where one code component may inadvertently override the implementation of another if the names are the same (for example, two functions with the same name). Using third-party frameworks and libraries can really increase the potential for these issues which is why most of them implement modularization.\
}